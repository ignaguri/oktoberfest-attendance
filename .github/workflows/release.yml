name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  packages: write

concurrency:
  group: release
  cancel-in-progress: true

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup PNPM
        uses: pnpm/action-setup@v2
        with:
          version: 10.14.0

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install dependencies (fallback)
        if: failure()
        run: pnpm install

      - name: Cache build artifacts
        uses: actions/cache@v4
        with:
          path: |
            .next
            .next/cache
          key: ${{ runner.os }}-next-build-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**/*.{js,jsx,ts,tsx}') }}
          restore-keys: |
            ${{ runner.os }}-next-build-${{ hashFiles('**/pnpm-lock.yaml') }}-
            ${{ runner.os }}-next-build-

      - name: Extract version from tag
        id: extract_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "NEW_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Generate changelog
        run: |
          pnpm run version:set ${{ env.NEW_VERSION }}

      - name: Build application
        run: pnpm run build

      - name: Create Release
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${process.env.NEW_VERSION}`,
              name: `Release v${process.env.NEW_VERSION}`,
              body: fs.readFileSync('CHANGELOG.md', 'utf8'),
              draft: false,
              prerelease: false
            });
            return release;

      - name: Upload release assets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Create a zip file of the .next directory
            const { execSync } = require('child_process');
            execSync('zip -r next-build.zip .next', { stdio: 'inherit' });

            // Upload the asset
            const { data: asset } = await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ steps.create_release.outputs.result.id }},
              name: 'next-build.zip',
              data: fs.readFileSync('next-build.zip'),
              headers: {
                'content-type': 'application/zip',
              },
            });

            console.log(`Asset uploaded: ${asset.browser_download_url}`);

      - name: Cleanup temporary files
        if: always()
        run: |
          rm -rf .next
          rm -f next-build.zip
          echo "Cleanup completed"

      - name: Cleanup old caches
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            // Clean up old caches (older than 30 days)
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            try {
              const { data: caches } = await github.rest.actions.getActionsCacheList({
                owner: context.repo.owner,
                repo: context.repo.repo,
                key: 'next-build-',
                per_page: 100
              });
              
              for (const cache of caches.actions_caches) {
                const cacheDate = new Date(cache.created_at);
                if (cacheDate < thirtyDaysAgo) {
                  await github.rest.actions.deleteActionsCacheById({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    cache_id: cache.id
                  });
                  console.log(`Deleted old cache: ${cache.key} (created: ${cache.created_at})`);
                }
              }
            } catch (error) {
              console.log('Cache cleanup completed (or no old caches found)');
            }
